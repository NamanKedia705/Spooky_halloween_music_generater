import pygame
import pygame_gui
import random
import threading
import time

# --- Constants ---
WINDOW_WIDTH = 800
WINDOW_HEIGHT = 600
WHITE = pygame.Color(255, 255, 255)
BLACK = pygame.Color(0, 0, 0)
BEAT_COLOR = pygame.Color(50, 50, 50)
BEAT_SELECTED_COLOR = pygame.Color(255, 0, 0)
BEAT_HIGHLIGHT_COLOR = pygame.Color(150, 100, 100, 200)

# --- Sound loading function ---
def load_sound(filename):
    """Load a sound file, or return a 'fake' sound object if it fails."""
    try:
        sound = pygame.mixer.Sound(filename)
    except pygame.error:
        print(f"Warning: Could not load sound file {filename}")
        class DummySound:
            def play(self): pass
        sound = DummySound()
    return sound
 
# --- Main application class ---
class SequencerApp:
    def __init__(self, manager):
        self.manager = manager
        
        # Sequencer data: 3 instruments, 8 steps
        self.beat_matrix = [[False for _ in range(8)] for _ in range(3)]
        self.instrument_names = ["Bass Drum", "Snare", "Hi-Hat"]
        self.current_step = -1
        self.is_playing = False
        self.tempo_bpm = 120
        self.halloween_playing = False
        self.stop_halloween_event = threading.Event()

        # Create GUI elements
        self.create_gui_elements()
        self.load_sounds()

        # Audio thread control
        self.audio_thread = None
        self.stop_thread = threading.Event()

    def create_gui_elements(self):
        """Build the user interface."""
        # Step sequencer grid
        self.beat_buttons = []
        for i in range(3): # Rows for each instrument
            row_buttons = []
            for j in range(8): # Columns for each step
                x = 100 + j * 70
                y = 100 + i * 50
                button_rect = pygame.Rect(x, y, 50, 40)
                button = pygame_gui.elements.UIButton(
                    relative_rect=button_rect,
                    text="",
                    manager=self.manager
                )
                button.instrument_index = i
                button.step_index = j
                row_buttons.append(button)
            self.beat_buttons.append(row_buttons)

        # Instrument labels
        for i, name in enumerate(self.instrument_names):
            label_rect = pygame.Rect(10, 100 + i * 50, 80, 40)
            pygame_gui.elements.UILabel(
                relative_rect=label_rect,
                text=name,
                manager=self.manager
            )
            
        # Tempo slider
        # Tempo label
        label_rect = pygame.Rect(10, 300, 80, 20)
        pygame_gui.elements.UILabel(relative_rect=label_rect, text="Tempo:", manager=self.manager)

        # Tempo slider
        slider_rect = pygame.Rect(100, 300, 200, 20)
        self.tempo_slider = pygame_gui.elements.UIHorizontalSlider(
            relative_rect=slider_rect,
            start_value=120,
            value_range=(60, 240),
            manager=self.manager
        )

        # Tempo text input (right next to slider)
        tempo_input_rect = pygame.Rect(320, 300, 60, 25)
        self.tempo_input = pygame_gui.elements.UITextEntryLine(
            relative_rect=tempo_input_rect,
            manager=self.manager
        )
        self.tempo_input.set_text(str(self.tempo_bpm))

        # Play/Stop buttons
        play_button_rect = pygame.Rect(10, 350, 100, 40)
        self.play_button = pygame_gui.elements.UIButton(
            relative_rect=play_button_rect,
            text="Play",
            manager=self.manager
        )
        
        stop_button_rect = pygame.Rect(120, 350, 100, 40)
        self.stop_button = pygame_gui.elements.UIButton(
            relative_rect=stop_button_rect,
            text="Stop",
            manager=self.manager
        )

        stop_halloween_rect = pygame.Rect(10, 470, 190, 40)
        self.stop_halloween_button = pygame_gui.elements.UIButton(
            relative_rect=stop_halloween_rect,
            text="Stop Halloween Track",
            manager=self.manager
        )
        # Convert to song button
        convert_button_rect = pygame.Rect(10, 425, 230, 40)
        self.convert_button = pygame_gui.elements.UIButton(
            relative_rect=convert_button_rect,
            text="Convert to Halloween Song",
            manager=self.manager
        )

    def load_sounds(self):
        """Loads sound effects into memory."""
        self.sounds = {
            "bass": load_sound("sounds/bass.wav"),
            "snare": load_sound("sounds/snare.wav"),
            "hihat": load_sound("sounds/hihat.wav"),
            "spooky_melody": load_sound("sounds/spooky_melody.wav")
        }
        self.instrument_sounds = [
            self.sounds["bass"],
            self.sounds["snare"],
            self.sounds["hihat"]
        ]

    def load_background(self):
        """Load the background image and scale it to fit the window."""
        try:
            bg = pygame.image.load("images/halloween_bg.jpg").convert()
            self.background = pygame.transform.scale(bg, (WINDOW_WIDTH, WINDOW_HEIGHT))
        except Exception as e:
            print("Warning: could not load background image:", e)
            self.background = None
    
    def handle_event(self, event):
        """Processes user input events."""
        if event.type == pygame.USEREVENT:
            if event.user_type == pygame_gui.UI_BUTTON_PRESSED:
                # Handle sequencer button clicks
                if hasattr(event.ui_element, 'instrument_index'):
                    instr = event.ui_element.instrument_index
                    step = event.ui_element.step_index
                    self.beat_matrix[instr][step] = not self.beat_matrix[instr][step]
                # Handle control button clicks
                elif event.ui_element == self.play_button:
                    self.start_playback()
                elif event.ui_element == self.stop_button:
                    self.stop_playback()
                elif event.ui_element == self.convert_button:
                    self.stop_playback()
                    self.convert_to_halloween_song()
                elif event.ui_element == self.stop_halloween_button:
                    # Stop the Halloween track
                    print("Stopping Halloween track...")
                    self.stop_halloween_event.set()     # signal to stop the Halloween thread
                    self.stop_spooky_background()       # stop spooky melody
                    self.halloween_playing = False
                    self.current_step = -1

    def start_playback(self):
        """Starts the audio playback loop in a separate thread."""
        if not self.is_playing:
            self.is_playing = True
            self.stop_thread.clear()
            self.audio_thread = threading.Thread(target=self.playback_loop)
            self.audio_thread.start()

    def stop_playback(self):
        """Stops the audio playback loop."""
        if self.is_playing:
            self.is_playing = False
            self.stop_thread.set()
            if self.audio_thread:
                self.audio_thread.join()
            self.current_step = -1

    def playback_loop(self):
        while not self.stop_thread.is_set():
            self.current_step = (self.current_step + 1) % 8
            
            for i in range(3):
                if self.beat_matrix[i][self.current_step]:
                    self.instrument_sounds[i].play()

            # Sleep but can be interrupted
            if self.stop_thread.wait(timeout=60.0 / self.tempo_bpm / 2):
                break

    def convert_to_halloween_song(self):
        """Start the Halloween song in a new thread."""
        if self.halloween_playing:
            return  # Already playing

        self.halloween_playing = True
        self.stop_halloween_event.clear()
        threading.Thread(target=self._halloween_song_loop, daemon=True).start()

    def _halloween_song_loop(self):
        """Actual Halloween song loop."""
        print("Mixing your beat with spooky sounds...")
        self.play_spooky_background()

        total_steps = 8
        for _ in range(16):  # Repeat 16 steps
            if self.stop_halloween_event.is_set():
                break
            for step in range(total_steps):
                if self.stop_halloween_event.is_set():
                    break
                for instr in range(3):
                    if self.beat_matrix[instr][step]:
                        self.instrument_sounds[instr].play()
                # Sleep based on tempo, but can wake early if stop pressed
                if self.stop_halloween_event.wait(timeout=60.0 / self.tempo_bpm / 2):
                    break  # Stop was pressed

        self.stop_spooky_background()
        time.sleep(0.1)  # short delay to prevent abrupt cutoff
        self.halloween_playing = False
        self.current_step = -1
        print("Halloween song completed or stopped.")

    def play_spooky_background(self):
        """Play the spooky melody in the background throughout the song."""
        print("Starting spooky melody...")
        self.sounds["spooky_melody"].play(loops=-1, maxtime=0)  # Play infinitely (looping)

    def stop_spooky_background(self):
        """Stop the spooky melody after the song is done."""
        self.sounds["spooky_melody"].stop()
        print("Stopped spooky melody")

    def update_gui(self):
        """Updates tempo and visuals."""
        # --- TEMPO LOGIC ---

        # Detect if user is typing (box is focused)
        if self.tempo_input.is_focused:
            try:
                # Try to parse the typed number
                typed_value = int(self.tempo_input.get_text())
                if 60 <= typed_value <= 240:
                    self.tempo_bpm = typed_value
                    self.tempo_slider.set_current_value(self.tempo_bpm)
            except ValueError:
                # Ignore invalid text while typing
                pass
        else:
            # If not typing, follow the slider value
            slider_value = int(self.tempo_slider.get_current_value())
            if slider_value != self.tempo_bpm:
                self.tempo_bpm = slider_value
                self.tempo_input.set_text(str(self.tempo_bpm))

        # --- BUTTON COLORS ---
        for i in range(3):
            for j in range(8):
                button = self.beat_buttons[i][j]

                if self.is_playing and j == self.current_step:
                    color = BEAT_HIGHLIGHT_COLOR
                elif self.beat_matrix[i][j]:
                    color = BEAT_SELECTED_COLOR
                else:
                    color = BEAT_COLOR

                if button.colours['normal_bg'] != color:
                    button.colours['normal_bg'] = color
                    button.colours['hovered_bg'] = color
                    button.colours['active_bg'] = color
                    button.rebuild()
    
def main():
    """Main function to run the application."""
    pygame.init()
    pygame.mixer.init()  # Ensure the mixer is initialized properly
    screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
    pygame.display.set_caption("Halloween Step Sequencer")
    clock = pygame.time.Clock()

    ui_manager = pygame_gui.UIManager((WINDOW_WIDTH, WINDOW_HEIGHT))
    app = SequencerApp(ui_manager)
    app.load_background()
    
    is_running = True
    while is_running:
        time_delta = clock.tick(60) / 1000.0
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                is_running = False

            # process events *first* so text boxes & sliders work
            ui_manager.process_events(event)
    
            # then handle custom app logic
            app.handle_event(event)
        
        ui_manager.update(time_delta)
        app.update_gui()

        if app.background:
            screen.blit(app.background, (0, 0))
        else:
            screen.fill(WHITE)

        ui_manager.draw_ui(screen)
        pygame.display.update()

    app.stop_playback()
    pygame.quit()

if __name__ == "__main__":
    main()
